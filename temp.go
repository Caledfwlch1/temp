package main

import (
	"fmt"
	"encoding/binary"
	"bytes"
	"io"
//	"bufio"
	"strings"
)

const (
	LenPacket 		= 2048
)

func main() { // Den: Лучше это сделать тестом.
	var h ISCSIConnection

	fmt.Println("start")
	//login packet

	pack := []byte{
		0x43, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, /* C....... */
		0x00, 0x02, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, /* ..=..... */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x6f, /* Initiato */
		0x72, 0x4e, 0x61, 0x6d, 0x65, 0x3d, 0x69, 0x71, /* rName=iq */
		0x6e, 0x2e, 0x31, 0x39, 0x39, 0x33, 0x2d, 0x30, /* n.1993-0 */
		0x38, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x64, 0x65, /* 8.org.de */
		0x62, 0x69, 0x61, 0x6e, 0x3a, 0x30, 0x31, 0x3a, /* bian:01: */
		0x31, 0x38, 0x37, 0x61, 0x39, 0x31, 0x61, 0x66, /* 187a91af */
		0x34, 0x30, 0x00, 0x49, 0x6e, 0x69, 0x74, 0x69, /* 40.Initi */
		0x61, 0x74, 0x6f, 0x72, 0x41, 0x6c, 0x69, 0x61, /* atorAlia */
		0x73, 0x3d, 0x73, 0x69, 0x74, 0x2d, 0x31, 0x39, /* s=sit-19 */
		0x32, 0x30, 0x00, 0x53, 0x65, 0x73, 0x73, 0x69, /* 20.Sessi */
		0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x3d, 0x44, /* onType=D */
		0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, /* iscovery */
		0x00, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x44, /* .HeaderD */
		0x69, 0x67, 0x65, 0x73, 0x74, 0x3d, 0x4e, 0x6f, /* igest=No */
		0x6e, 0x65, 0x00, 0x44, 0x61, 0x74, 0x61, 0x44, /* ne.DataD */
		0x69, 0x67, 0x65, 0x73, 0x74, 0x3d, 0x4e, 0x6f, /* igest=No */
		0x6e, 0x65, 0x00, 0x44, 0x65, 0x66, 0x61, 0x75, /* ne.Defau */
		0x6c, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x32, 0x57, /* ltTime2W */
		0x61, 0x69, 0x74, 0x3d, 0x32, 0x00, 0x44, 0x65, /* ait=2.De */
		0x66, 0x61, 0x75, 0x6c, 0x74, 0x54, 0x69, 0x6d, /* faultTim */
		0x65, 0x32, 0x52, 0x65, 0x74, 0x61, 0x69, 0x6e, /* e2Retain */
		0x3d, 0x30, 0x00, 0x49, 0x46, 0x4d, 0x61, 0x72, /* =0.IFMar */
		0x6b, 0x65, 0x72, 0x3d, 0x4e, 0x6f, 0x00, 0x4f, /* ker=No.O */
		0x46, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x3d, /* FMarker= */
		0x4e, 0x6f, 0x00, 0x45, 0x72, 0x72, 0x6f, 0x72, /* No.Error */
		0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, /* Recovery */
		0x4c, 0x65, 0x76, 0x65, 0x6c, 0x3d, 0x30, 0x00, /* Level=0. */
		0x4d, 0x61, 0x78, 0x52, 0x65, 0x63, 0x76, 0x44, /* MaxRecvD */
		0x61, 0x74, 0x61, 0x53, 0x65, 0x67, 0x6d, 0x65, /* ataSegme */
		0x6e, 0x74, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, /* ntLength */
		0x3d, 0x33, 0x32, 0x37, 0x36, 0x38, 0x00, 0x00} /* =32768.. */



	buf := bytes.NewReader(pack)
	n, err := h.ReadFrom(buf)
	fmt.Println("65 - n=", n, "\n65 - err=", err) // , "\n65 - h=", h)

	bufw := bytes.NewBuffer(nil)
	n, err = h.WriteTo(bufw)
	fmt.Println("69 - n=", n, "\n69 - err=", err, "\n69 - buf=", bufw, "len(buf)=", bufw.Len())

	return
}

type LoginHeader struct {
	OpCode		byte		// 1 byte
	OpCodeSF	byte		// 1 byte OpCodeSpcField
	I		bool		// Immediate bit
	T		bool		// Transit bit
	C		bool		// Continue bit
	CSG		int		// Current stage
	NSG		int		// Next stage
	VerMax		byte		// 1 byte
	VerMin		byte		// 1 byte
	TotAHSLen	int		// 1 byte
	DataSegLen	int		// 3 bytes
	ISID		[]byte		// 6 bytes
	TSIH		[]byte		// 2 bytes
	InitTaskTag	[]byte		// 4 bytes
	CID		[]byte		// 2 bytes
	Res1		[]byte		// 2 bytes
	CmdSN		int		// 4 bytes
	ExpStatSN	int		// 4 bytes
	Res2		[]byte		// 16 bytes
	DataW		[]byte		//
	msg		Msg
}

var _ Msg = (*LoginHeader)(nil)

type ISCSIConnection struct {
	LH	LoginHeader
	DS	map[string]string	// Login parameters
	DataR	[]byte			// Data read from ...
	DataW	[]byte			// Data write to ...
}

type Msg interface {
	ReadFrom(io.Reader) (int, error)
	WriteTo(io.Writer) (int, error)
//	Close(io.ReadWriteCloser) (error)
}

func (p *LoginHeader) ReadFrom(r io.Reader) (int, error) {
	buf := make([]byte, 48)
	n, err := io.ReadFull(r, buf)

	p.I		= selectBit((buf[0]), 0x40)
	p.OpCode 	= buf[0] & 0x3f
	p.OpCodeSF	= buf[1]
	p.T		= selectBit(p.OpCodeSF, 0x80)
	p.C		= selectBit(p.OpCodeSF, 0x40)
	p.CSG		= int(binary.BigEndian.Uint16([]byte{0, selectBits(p.OpCodeSF, 0x0c)}))
	p.NSG		= int(binary.BigEndian.Uint16([]byte{0, selectBits(p.OpCodeSF, 0x03)}))
	p.VerMax	= buf[2]
	p.VerMin	= buf[3]
	p.TotAHSLen	= int(binary.BigEndian.Uint16([]byte{0, buf[4]}))
	p.DataSegLen	= int(binary.BigEndian.Uint32(append([]byte{0}, buf[5:8]...)))
	p.ISID		= buf[8:14]
	p.TSIH		= buf[14:16]
	p.InitTaskTag	= buf[16:20]
	p.CID		= buf[20:22]
	p.Res1		= buf[22:24]
	p.CmdSN		= int(binary.BigEndian.Uint32(buf[24:28]))
	p.ExpStatSN	= int(binary.BigEndian.Uint32(buf[28:32]))
	p.Res2		= buf[32:]
	return n, err
}

func (p *ISCSIConnection)ReadFrom(r io.Reader) (int, error) {

	n, err := p.LH.ReadFrom(r)

	buf := make([]byte, p.LH.DataSegLen)
	n, err = io.ReadFull(r, buf)

	p.Decode(buf)


	return n, err
}

func (p *ISCSIConnection) Decode(d []byte) error {
	p.DS = make(map[string]string, 0)
	arrString := strings.Split(string(d), string("\x00"))
	for _, element := range arrString {
		if strings.Contains(element, "=") {
			ar := strings.Split(element, "=")
			p.DS[ar[0]] = ar[1]
		}
	}
    return nil
}

func selectBit(bi, bc byte) (bool) {
	return (bi & bc) == bc
}

func selectBits(bi, bc byte) (byte) {
	return (bi & bc)
}

func (p LoginHeader)String() (string) {
	return fmt.Sprintf("p.OpCode=%x, p.OpCodeSF=%x, p.I=%t, p.T=%t, p.C=%t, p.CSG=%d, p.NSG=%d, p.VerMax=%x, p.VerMin=%x, p.TotAHSLen=%d,"+
			" p.DataSegLen=%d, p.ISID=%x, p.TSIH=%x, p.InitTaskTag=%x, p.CID=%x, p.Res1=%x, p.CmdSN=%d,"+
			" p.ExpStatSN=%d, p.Res2=%x",
			p.OpCode, p.OpCodeSF, p.I, p.T, p.C, p.CSG, p.NSG, p.VerMax, p.VerMin, p.TotAHSLen,
			p.DataSegLen, p.ISID, p.TSIH, p.InitTaskTag, p.CID, p.Res1, p.CmdSN,
			p.ExpStatSN, p.Res2)
}

func (p ISCSIConnection)String() (string) {
	out := ""
	for i, j := range p.DS {
		out += " " + fmt.Sprint(i) + "=" + fmt.Sprint(j)
	}
	return fmt.Sprintf("LoginHeader=%s, \nParam=%s", p.LH, out)
}

func (p *ISCSIConnection)WriteTo(w io.Writer) (int, error) {
	p.MakePacket()
	n, err := w.Write(p.DataW)
	return n, err
}

func (p *LoginHeader)WriteTo(w io.Writer) (int, error) {
	n, err := w.Write(p.DataW)
	return n, err
}

func (p *ISCSIConnection)MakePacket() {



	p.DataW = []byte{0x43, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf7, /* C....... */
			0x00, 0x02, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, /* ..=..... */
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, /* ........ */
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	return
}

